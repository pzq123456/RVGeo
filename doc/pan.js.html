<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>RVGeo: Source: pan.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: pan.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Point }  from './base.js';
import { ColorRamp } from './display.js';


/**
 * 画笔类 负责将内容绘制到canvas上 仅用于渲染矢量图形
 * - 可能叫renderer更加专业一点
 */
export class pan { 
    /**
     * 构造画笔 
     * @param {CanvasRenderingContext2D} ctx - 获取二维canvas上下文
     * @param {string} color - 画笔颜色
     */
    constructor(ctx,color) {
        this.ctx = ctx;
        this.color = color;
    }
    /**
     * 绘点
     * @param {number} x - 横坐标
     * @param {number} y - 纵坐标
     * 直接在上下文中绘制
     */
    draw_point(x,y){
        this.ctx.fillStyle = this.color;
        this.ctx.fillRect(x, y, 10, 10);
    }

    /**
     * 绘制点集
     * @param {array} pointlist 
     */
    draw_pointset(pointlist){
        for (let it of pointlist){
            this.draw_point(it.x,it.y);
        }
    }

    /**
     * 绘制单一直线
     * @param {Point} sp - start point
     * @param {Point} ep - end point
     */
    draw_line(sp,ep){
        this.ctx.lineWidth = 3 ;
        this.ctx.beginPath();
        this.ctx.moveTo(sp.x,sp.y);
        this.ctx.lineTo(ep.x,ep.y);
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = 3 ;
        this.ctx.closePath();
        this.ctx.stroke();
    }


    /**
     * 绘制填充多边形
     * @param {array} pointlist 
     */
    draw_polygon(pointlist){
        //this.ctx.fillStyle = "#0000ff5a";
        this.ctx.strokeStyle = this.color;
        this.ctx.lineWidth = 3 ;
        this.ctx.beginPath();

        this.ctx.moveTo(pointlist[0].x,pointlist[0].y);
        for(let i=1;i&lt;pointlist.length;i++){
            this.ctx.lineTo(pointlist[i].x,pointlist[i].y);
        }
        //this.ctx.fill();
        this.ctx.closePath();
        this.ctx.stroke();
       
    }
    
    /**
     * 绘制折线
     * @param {array} pointlist 
     */
     draw_complexline(pointlist){
        this.ctx.strokeStyle =this.color;
        this.ctx.lineWidth = 3 ;
        this.ctx.beginPath();
        this.ctx.moveTo(pointlist[0].x,pointlist[0].y);
        for(let i=1;i&lt;pointlist.length;i++){
            this.ctx.lineTo(pointlist[i].x,pointlist[i].y);
        }
        this.ctx.stroke();
       
    }

    /**
     * 绘制矩形框 [x1,y1,x2,y2]
     * @param {array} list1
     */
    draw_rect(list1){
        let list = list1.slice();
        this.ctx.strokeStyle =this.color;
        this.ctx.lineWidth = 3 ;
        this.ctx.beginPath();
        this.ctx.moveTo(list[0],list[1]);
        this.ctx.lineTo(list[2],list[1]);
        this.ctx.lineTo(list[2],list[3]);
        this.ctx.lineTo(list[0],list[3]);
        this.ctx.closePath();
        this.ctx.stroke();
    }

    /**
     * 绘制三角形
     * @param {array} list - 三角形的点表
     */
    draw_triangle(list){
        this.ctx.strokeStyle =this.color;
        this.ctx.lineWidth = 3 ;
        this.ctx.beginPath();
        this.ctx.moveTo(list[0].x,list[0].y);
        this.ctx.lineTo(list[1].x,list[1].y);
        this.ctx.lineTo(list[2].x,list[2].y);
        this.ctx.closePath();
        this.ctx.stroke();
    }

    /**
     * 绘制圆
     * @param {number} x - 圆心x坐标
     * @param {number} y - 圆心y坐标
     * @param {number} r - 外接圆半径
     */
    draw_circle(x,y,r)
    {
        // 开始绘制路径
        this.ctx.beginPath();
        this.ctx.lineWidth = 2;
        this.ctx.strokeStyle = this.color;
        // 绘制圆的路径
        this.ctx.arc(x, y, r, 0, Math.PI * 2, false);
        // 描边路径
        this.ctx.stroke();
    }





    /**
     * 绘制直线（array表示）
     * @param {array} list - [x1,y1,x2,y2]
     */
     draw_line_arr(list){
        
        let x1 = list[0];
        let y1 = list[1];
        let x2 = list[2];
        let y2 = list[3];

        this.ctx.lineWidth = 2 ;
        this.ctx.beginPath();

        this.ctx.moveTo(x1,y1);
        this.ctx.lineTo(x2,y2);

        this.ctx.strokeStyle = this.color;

        this.ctx.closePath();
        this.ctx.stroke();
    }


    /**
     * 绘制栅格单元
     * @param {number} x - 横坐标
     * @param {number} y - 纵坐标
     * @param {number} dx - 栅格单元大小 需要计算得出
     * @param {number} dy - 栅格单元大小 需要计算得出
     * @param {string} color - 栅格单元颜色 需要计算得出
     * */
     draw_GridCell(x,y,dx,dy,color){
        this.ctx.fillStyle = color;
        this.ctx.fillRect(x,y,dx,dy);
    }
    /**
     * 绘制文字
     * @param {string} text 
     * @param {number} x 
     * @param {number} y 
     */
    draw_text(text,x,y){
        this.ctx.font = 'oblique 20px Arial';
        this.ctx.fillText(text,x,y);
    }
}

/**
 * 栅格色彩渲染器 将栅格值渲染为可供浏览器渲染的字符串，
 * 提供各种颜色渲染方案 
 * * 与pan类的区别：pan类可以在canvas上绘制，而本类仅完成值的转换
 * * 即只完成由value到字符串的转换
 */
export class CellValueRenderer{
   /**
    * **取值限制[0,255]**
    * 该方法将对应的栅格值（value）映射为灰度图
    * @param {number} value - 输入的栅格值
    * @param {number} alpha - 渲染该层的透明度
    * @returns {string} 返回描述颜色的字符串 包括rgb和rgba两种格式
    */
    static  Gray(value,ISReversed,alpha){
        if(ISReversed) {
            value = 1 - value; 
        }
     let r = 255*value;
     let g = r;
     let b = r;
     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

    /**
    * **取值限制[0,3]**
    * 该方法将对应的栅格值（value）映射为灰度图
    * @param {number} value - 输入的栅格值
    * @param {number} alpha - 渲染该层的透明度
    * @returns {string} 返回描述颜色的字符串 包括rgb和rgba两种格式
    */
    static  ColorBand_1(value,alpha){
    
    let r,g,b;

    if(value == 0 ){
        r=0;
        g=0;
        b=0;
    }
    if(value == 1){
        r=255;
        g=0;
        b=0;
    }
    if(value == 2){
        r=0;
        g=255;
        b=0;
    }
    if(value == 3){
        r=0;
        g=0;
        b=255;
    }

     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   static ColorBand_2(value,alpha){
    let r,g,b;

    if(value == 0 ){
        r=160;
        g=32;
        b=240;
    }
    if(value == 1){
        r=255;
        g=105;
        b=180;
    }
    if(value == 2){
        r=255;
        g=165;
        b=0;
    }
    if(value == 3){
        r=0;
        g=255;
        b=255;
    }

     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   /**
    * **取值限制[0,255]**
    * @param {number} value 
    * @param {number} alpha 
    * @returns 
    */
    static Red(value,ISReversed,alpha){
        if(ISReversed) {
            value = 1 - value; 
        }
     let r = 255*value;
     let g = 0;
     let b = 0;
     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   /**
    * **取值限制[0,255]**
    * @param {*} value 
    * @param {*} alpha 
    * @returns 
    */
    static Green(value,ISReversed,alpha){
        if(ISReversed) {
            value = 1 - value; 
        }
     let r = 0;
     let g = 255*value;
     let b = 0;
     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   /**
    * **取值限制[0,255]**
    * @param {*} value 
    * @param {*} alpha 
    * @returns 
    */
    static Blue(value,ISReversed,alpha){
        if(ISReversed) {
            value = 1 - value; 
        }
     let r = 0 ;
     let g = 0 ;
     let b = 255*value;
     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   /**
    * **取值限制[0,255]**
    * @param {*} value 
    * @param {*} alpha 
    * @returns 
    */
    static Yellow(value,ISReversed,alpha){
        if(ISReversed) {
            value = 1 - value; 
        }
     let r = 255*value ;
     let g = 255*value ;
     let b = 0;
     if(alpha == undefined){
        return "rgb("+r+","+g+","+b+")";
     }
     return "rgba("+r+","+g+","+b+","+alpha+")";
   }

   /**
    * **渲染坡向（0-360）**
    * @param {number} value 
    * @returns 
    */
    static  Aspact(value){
        let r,g,b ;
     if(value&lt;22.5){
       [r,g,b] = [255,0,0];
     }
     else if(value&lt;67.5){
        [r,g,b] = [255,165,0];
     }
     else if(value&lt;112.5){
       [r,g,b] = [255,255,0];
     }
     else if(value&lt;157.5){
       //return this.rgb_renderer(255,200,0);
       [r,g,b] = [0,255,0];
     }
     else if(value&lt;202.5){
        [r,g,b] = [0,255,255];
     }
     else if(value&lt;247.5){
        [r,g,b] = [135,206,250];//LightSkyBlue 135,206,250
     }
     else if(value&lt;292.5){
        [r,g,b] = [0,0,255];
     }
     else if(value&lt;337.5){
        [r,g,b] = [139,0,255];
     }
     else {
        [r,g,b] = [255,0,0];
     }
    return "rgb("+r+","+g+","+b+")";
   } 

   static  Pure(value,ISReversed,alpha){
    if(ISReversed) {
        value = 1 - value; 
    }
   let r = 255*value;
   let g = 150*r;
   let b = 20*r;
   if(alpha == undefined){
      return "rgb("+r+","+g+","+b+")";
   }
   return "rgba("+r+","+g+","+b+","+alpha+")";
}


   
 }


 


</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CellValueRenderer.html">CellValueRenderer</a></li><li><a href="Circle.html">Circle</a></li><li><a href="ColorRamp.html">ColorRamp</a></li><li><a href="grid_grid.html">grid</a></li><li><a href="GridView.html">GridView</a></li><li><a href="Line.html">Line</a></li><li><a href="LineView.html">LineView</a></li><li><a href="pan.html">pan</a></li><li><a href="Point.html">Point</a></li><li><a href="PointSet.html">PointSet</a></li><li><a href="PointSetView.html">PointSetView</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="SimpleLine.html">SimpleLine</a></li><li><a href="Stastic.html">Stastic</a></li><li><a href="StasticView.html">StasticView</a></li><li><a href="Tensor_2D.html">Tensor_2D</a></li><li><a href="Triangle.html">Triangle</a></li><li><a href="TriangleView.html">TriangleView</a></li><li><a href="Vector_nD.html">Vector_nD</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dedupPointList_">dedupPointList_</a></li><li><a href="global.html#dedupSimpleLineList_">dedupSimpleLineList_</a></li><li><a href="global.html#del_getSuperTriangle">del_getSuperTriangle</a></li><li><a href="global.html#Delaunay_triangulation">Delaunay_triangulation</a></li><li><a href="global.html#Douglas_Peuker">Douglas_Peuker</a></li><li><a href="global.html#Douglas_Peuker_kernel">Douglas_Peuker_kernel</a></li><li><a href="global.html#getbidirectionalHausdorffDistance">getbidirectionalHausdorffDistance</a></li><li><a href="global.html#getClockwiseFea">getClockwiseFea</a></li><li><a href="global.html#getconvex_hull">getconvex_hull</a></li><li><a href="global.html#getExtentOfPointSet">getExtentOfPointSet</a></li><li><a href="global.html#getPoint2LineDistence">getPoint2LineDistence</a></li><li><a href="global.html#getTwoLineFromeOne">getTwoLineFromeOne</a></li><li><a href="global.html#getunidirectionalHausdorffDistance">getunidirectionalHausdorffDistance</a></li><li><a href="global.html#IsPointonLine">IsPointonLine</a></li><li><a href="global.html#kernel_1">kernel_1</a></li><li><a href="global.html#kernel_2">kernel_2</a></li><li><a href="global.html#kernel_2Dmatrix_1">kernel_2Dmatrix_1</a></li><li><a href="global.html#kernel_2Dmatrix_2">kernel_2Dmatrix_2</a></li><li><a href="global.html#kernel_2Dmatrix_3">kernel_2Dmatrix_3</a></li><li><a href="global.html#kernel_2Dmatrix_cal">kernel_2Dmatrix_cal</a></li><li><a href="global.html#kernel_3">kernel_3</a></li><li><a href="global.html#kernel_4">kernel_4</a></li><li><a href="global.html#kernel_5">kernel_5</a></li><li><a href="global.html#kernel_6">kernel_6</a></li><li><a href="global.html#kernel_7">kernel_7</a></li><li><a href="global.html#kernel_8">kernel_8</a></li><li><a href="global.html#kernel_arr_1">kernel_arr_1</a></li><li><a href="global.html#kernel_arr_2">kernel_arr_2</a></li><li><a href="global.html#kernel_arr_3">kernel_arr_3</a></li><li><a href="global.html#kernel_arr_4">kernel_arr_4</a></li><li><a href="global.html#kernel_arr_5">kernel_arr_5</a></li><li><a href="global.html#kernel_arr_6">kernel_arr_6</a></li><li><a href="global.html#kernel_arr_7">kernel_arr_7</a></li><li><a href="global.html#kernel_arr_8">kernel_arr_8</a></li><li><a href="global.html#kernel_arr_9">kernel_arr_9</a></li><li><a href="global.html#kernel_arr_10">kernel_arr_10</a></li><li><a href="global.html#kernel_arr_11">kernel_arr_11</a></li><li><a href="global.html#parser_1">parser_1</a></li><li><a href="global.html#SolveLineForm">SolveLineForm</a></li><li><a href="global.html#Tesson_polygon_adj_Matrix">Tesson_polygon_adj_Matrix</a></li><li><a href="global.html#test_1">test_1</a></li><li><a href="global.html#test_2">test_2</a></li><li><a href="global.html#test_3">test_3</a></li><li><a href="global.html#test_4">test_4</a></li><li><a href="global.html#test_5">test_5</a></li><li><a href="global.html#test_6">test_6</a></li><li><a href="global.html#test_7">test_7</a></li><li><a href="global.html#test_8">test_8</a></li><li><a href="global.html#test_9">test_9</a></li><li><a href="global.html#test_10">test_10</a></li><li><a href="global.html#x_sort">x_sort</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Oct 23 2022 21:29:57 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
