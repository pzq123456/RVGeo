<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>RVGeo: Source: learn.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: learn.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * stactic learning 
 * 处理 聚类、统计学习 等方面的内容
 */
import {kernel_1,kernel_2} from './kernel.js'
import { test_9,test_10} from './test.js';
/**
 * n维向量 代表 一个数据样本 或者是数据列表中的一行
 * 封装了一些求距离的方法（n维情形下）
 * * `functionname_()` 表示对某对象的运算
 */
class Vector_nD{
    /**
     * 实例化一个n维向量 需要传入一个n维数组
     * @param {array} ndarr - 传入的数组
     */
    constructor(ndarr){
        this.data = ndarr ;
        this.Dimension = ndarr.length;
    }

    /**
     * 计算 **n维** 欧氏距离(Euclidean Distance)
     * @param {Vector_nD} Invec - 输入的另一个n维向量
     * @return {number} - 返回欧氏距离
     */
     getEDistance_(Invec) {
        let Inarr = Invec.data;
        let Dimension = this.Dimension;
        if(this.Dimension > Inarr.length){
            Dimension = Inarr.length;
        } // 仅对有效的维度求距离
        let res = 0;
        for(let i=0 ;i &lt; Dimension;i++){
            res = res + kernel_1(this.data[i],Inarr[i]);
        }
        return Math.sqrt(res);
    }

    /**
     * 曼哈顿距离(Manhattan Distance) Chebyshev distance
     * @param {Vector_nD} Invec - 输入
     * @return {number} - 返回曼哈顿距离
     */
     getMDistance_(Invec) {
        let Inarr = Invec.data;
        // return kernel_2(this.x,InPoint.x)+kernel_2(this.y,InPoint.y);
        let Dimension = this.Dimension;
        if(this.Dimension > Inarr.length){
            Dimension = Inarr.length;
        } // 仅对有效的维度求距离

        let res = 0;
        for(let i=0 ;i &lt; Dimension;i++){
            res = res + kernel_2(this.data[i],Inarr[i]);
        }
        return res;
    }

     /**
     * 切比雪夫距离(Chebyshev distance) : max(|a-b|...)
     * @param {Vector_nD} Invec - 输入
     * @return {number} - 返回两点间的切比雪夫距离
     */
      getCDistance_(Invec) {
        let Inarr = Invec.data;
        let Dimension = this.Dimension;
        if(this.Dimension > Inarr.length){
            Dimension = Inarr.length;
        } // 仅对有效的维度求距离
        let res = [];
        for(let i=0 ;i &lt; Dimension;i++){
            res.push(kernel_2(this.data[i],Inarr[i]));
        }
        res.sort((a,b)=> a - b);
        return res[res.length-1];
    }

    /**
     * 闵氏距离(Minkowski Distance) : (｜a-b｜^p+...)^(1/p)
     * @param {Vector_nD} Invec - 输入
     * @param {number} p - 闵氏距离的维度
     * @return {number} - 返回两点间的闵氏距离
     */
     getMKDistance_(Invec,p) {
        let Inarr = Invec.data;
        let Dimension = this.Dimension;
        if(this.Dimension > Inarr.length){
            Dimension = Inarr.length;
        } // 仅对有效的维度求距离
        let res = 0;
        for(let i=0 ;i &lt; Dimension ; i++){
            res = res + Math.pow(kernel_2(this.data[i],Inarr[i]),p);
        }
        return Math.pow(res,Math.pow(p,-1));
        }
}

/**
 * 二维Tensor 每一行是一维vector 用来表示一组数据
 */
export class Tensor_2D{
    /**
     * 创建二维Tensor 可以从二维array构造
     * @param {array} arr2D - 二维array
     */
    constructor(arr2D){
        this.data = arr2D;
        this.row = arr2D.length;
        this.column = arr2D[0].length;
        this.shape=[this.row,this.column];
    }

    get_centroid(){
        let res = [];
        for(let i = 0;i&lt;this.column;i++){
            let sum = 0;
            for(let j=0;j&lt;this.row;j++){
                sum = sum + this.data[j][i];
            }
            res.push(sum/this.row);
        }
        return res;
    }

    // /**
    //  * 
    //  * @param {number} k 
    //  * @returns 
    //  */
    /**
     * k均值聚类
     * @param {number} k - 分类个数
     * @param {number} thresh - 质心间变化距离
     * @param {number} maxtime - 最大迭代次数
     * @returns 
     * * `groups.length = k` :[
     * [group1],
     * [group2],...
     * ]
     */
    K_means(k,thresh,maxtime){

        /*
        1.从样本中选择 K 个点作为初始质心（完全随机）
        2.计算每个样本到各个质心的距离，将样本划分到距离最近的质心所对应的簇中
        3.计算每个簇内所有样本的均值，并使用该均值更新簇的质心
        4.重复步骤 2 与 3 ，直到达到以下条件之一：
            质心的位置变化小于指定的阈值（默认为 0.0001）;
            达到最大迭代次数
         */

        if(k>this.row){
            return [];//若要分类别大于记录数 返回空array
        }

        let list =this.data.slice();
        let sample = test_9(this.row,k);// 随机取k个样本点 作为聚类中心

        let centroid = []; // 按照样本点的索引取值
        for(let itm of sample){
            centroid.push(this.data[itm]);
        }

        let dc = Infinity; // 两次聚类质心的变化距离
        let times = 0; //迭代次数

        let groups = []; //k groups

        while( dc > thresh || times &lt; maxtime ){ //若两次聚类质心距离小于阈值 或 超过最大迭代次数 则退出循环
            groups.length = k;
            for(let i =0;i &lt; k;i++){
                groups[i] = []; //初始化分类数组
            }

            //开始遍历
            for(let j=0; j&lt;list.length; j++){ //每一个向量
                let vec = new Vector_nD(list[j]);
                let min = 99999;
                let tit;
                for(let i =0;i&lt;k;i++){//每一个中心点
                    let centroid_ = new Vector_nD(centroid[i]);
                    let dis = centroid_.getEDistance_(vec);
                    if(dis &lt; min){
                        tit = i;
                        min = dis;
                    }
                    else continue;
                }
                
                groups[tit].push(list[j]);       
            }
            
            let sum = 0;
            for(let i = 0;i&lt;k;i++){// update centroid
                let ten = new Tensor_2D(groups[i]);

                let v1 = new Vector_nD(centroid[i]);
                let v2 = new Vector_nD(ten.get_centroid());
                sum =sum + v1.getEDistance_(v2);
                centroid[i] = ten.get_centroid();
            }
            dc = sum / k;
            times = times + 1;
        }
        return groups;
    }
}


// let ten = new Tensor_2D(test_10(10,3,100));
// console.log(ten.K_means(3,0.01,10));
// console.log(ten.K_means(2));
// console.log(ten.data);
// console.log(ten.row);
// console.log(ten.column);
// console.log(ten.shape);
// let ve = new Vector_nD(arr);
// console.log(ve.getEDistance_(arr2));
// console.log(ve.getMKDistance_(arr2,2));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CellValueRenderer.html">CellValueRenderer</a></li><li><a href="Circle.html">Circle</a></li><li><a href="ColorRamp.html">ColorRamp</a></li><li><a href="grid_grid.html">grid</a></li><li><a href="GridView.html">GridView</a></li><li><a href="Line.html">Line</a></li><li><a href="LineView.html">LineView</a></li><li><a href="pan.html">pan</a></li><li><a href="Point.html">Point</a></li><li><a href="PointSet.html">PointSet</a></li><li><a href="PointSetView.html">PointSetView</a></li><li><a href="Polygon.html">Polygon</a></li><li><a href="SimpleLine.html">SimpleLine</a></li><li><a href="Stastic.html">Stastic</a></li><li><a href="StasticView.html">StasticView</a></li><li><a href="Tensor_2D.html">Tensor_2D</a></li><li><a href="Triangle.html">Triangle</a></li><li><a href="TriangleView.html">TriangleView</a></li><li><a href="Vector_nD.html">Vector_nD</a></li></ul><h3>Global</h3><ul><li><a href="global.html#dedupPointList_">dedupPointList_</a></li><li><a href="global.html#dedupSimpleLineList_">dedupSimpleLineList_</a></li><li><a href="global.html#del_getSuperTriangle">del_getSuperTriangle</a></li><li><a href="global.html#Delaunay_triangulation">Delaunay_triangulation</a></li><li><a href="global.html#Douglas_Peuker">Douglas_Peuker</a></li><li><a href="global.html#Douglas_Peuker_kernel">Douglas_Peuker_kernel</a></li><li><a href="global.html#getbidirectionalHausdorffDistance">getbidirectionalHausdorffDistance</a></li><li><a href="global.html#getClockwiseFea">getClockwiseFea</a></li><li><a href="global.html#getconvex_hull">getconvex_hull</a></li><li><a href="global.html#getExtentOfPointSet">getExtentOfPointSet</a></li><li><a href="global.html#getPoint2LineDistence">getPoint2LineDistence</a></li><li><a href="global.html#getTwoLineFromeOne">getTwoLineFromeOne</a></li><li><a href="global.html#getunidirectionalHausdorffDistance">getunidirectionalHausdorffDistance</a></li><li><a href="global.html#IsPointonLine">IsPointonLine</a></li><li><a href="global.html#kernel_1">kernel_1</a></li><li><a href="global.html#kernel_2">kernel_2</a></li><li><a href="global.html#kernel_2Dmatrix_1">kernel_2Dmatrix_1</a></li><li><a href="global.html#kernel_2Dmatrix_2">kernel_2Dmatrix_2</a></li><li><a href="global.html#kernel_2Dmatrix_3">kernel_2Dmatrix_3</a></li><li><a href="global.html#kernel_2Dmatrix_cal">kernel_2Dmatrix_cal</a></li><li><a href="global.html#kernel_3">kernel_3</a></li><li><a href="global.html#kernel_4">kernel_4</a></li><li><a href="global.html#kernel_5">kernel_5</a></li><li><a href="global.html#kernel_6">kernel_6</a></li><li><a href="global.html#kernel_7">kernel_7</a></li><li><a href="global.html#kernel_8">kernel_8</a></li><li><a href="global.html#kernel_arr_1">kernel_arr_1</a></li><li><a href="global.html#kernel_arr_2">kernel_arr_2</a></li><li><a href="global.html#kernel_arr_3">kernel_arr_3</a></li><li><a href="global.html#kernel_arr_4">kernel_arr_4</a></li><li><a href="global.html#kernel_arr_5">kernel_arr_5</a></li><li><a href="global.html#kernel_arr_6">kernel_arr_6</a></li><li><a href="global.html#kernel_arr_7">kernel_arr_7</a></li><li><a href="global.html#kernel_arr_8">kernel_arr_8</a></li><li><a href="global.html#kernel_arr_9">kernel_arr_9</a></li><li><a href="global.html#kernel_arr_10">kernel_arr_10</a></li><li><a href="global.html#kernel_arr_11">kernel_arr_11</a></li><li><a href="global.html#parser_1">parser_1</a></li><li><a href="global.html#SolveLineForm">SolveLineForm</a></li><li><a href="global.html#Tesson_polygon_adj_Matrix">Tesson_polygon_adj_Matrix</a></li><li><a href="global.html#test_1">test_1</a></li><li><a href="global.html#test_2">test_2</a></li><li><a href="global.html#test_3">test_3</a></li><li><a href="global.html#test_4">test_4</a></li><li><a href="global.html#test_5">test_5</a></li><li><a href="global.html#test_6">test_6</a></li><li><a href="global.html#test_7">test_7</a></li><li><a href="global.html#test_8">test_8</a></li><li><a href="global.html#test_9">test_9</a></li><li><a href="global.html#test_10">test_10</a></li><li><a href="global.html#x_sort">x_sort</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.11</a> on Sun Oct 23 2022 21:29:57 GMT+0800 (中国标准时间)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
