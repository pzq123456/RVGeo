# A Brief Tutorial for Experiment of Spatial Analysis
> - Pan 6.19 `14:00`
> - 本文主要介绍一下个人对空间分析实习的一些想法，**水平有限**。若有错误，欢迎批评指正。
> - 在 `GitHub`上修改 [本文档](https://github.com/pzq123456/RVGeo/tree/main/docs) 。拉取、提交 `Pull Request` 即可。

## 项目结构方面的建议
具体算法可以首先整合到一个单独的核心算法包（库）中，交互式界面可以在此基础之上构建。在包的编写过程中，注意将相似功能的代码放到一个文件（文件夹）下，并整理好接口以方便调用。例如：
```
/YourApp             |      /你的项目
    /core            |          /核心算法库
        /Index       |              /接口
        /Base        |              /基础类
        /Vector      |              /矢量
        /Raster      |              /栅格
        /Utils       |              /通用工具
        /Renderer    |              /渲染
    /UI              |          /用户交互界面
        /Canvas      |              /画板
        /Brushes     |              /画刷
        /Actions     |              /对话框
        /Utils       |              /通用工具
    /Docs            |          /文档
    /Others          |          /其他
```
> 建议在开始写本次实习的代码之前，先将去年的代码整理一下，按照一定的逻辑组织起来。

- `Core/Base/` :
核心算法包中，可以首先编写底层的类（点线等），并将一些常用的算法写进去（计算距离、求交等）。这样，我们后续的算法实现就有了基础的对象。交互式绘制和分析时，我们本质上就是在**操作这些对象并不断触发渲染**。这样设计还有一个好处，我们可以依照这些基础类的属性值设计对对应的数据库表，为后续的功能拓展做准备。例如，画板内容的持久化存储，我们在绘制完后可以导出文件，下一次就只需要读取该文件并初始化有关的类。
> 建议将数据和具体的显示（渲染）分开，几何数据和统计数据分开。
-  `Core/Renderer/` : 
该类负责将我们的数据画出来，在浏览器中就是调用 2D Canvas 的 Context 接口。可以以类为单位封装，这样只需要几行代码就可以渲染。比如说：
> 以下代码仅仅介绍思路，不可以实际运行
```js
// base.js
class MyPointClass{
    // ...
}

// renderer.js
class brush{
    // 如果不想每次都输入ctx 可以在初始化里就注册 ctx
    // 初始化也可以设置画刷的颜色、宽度等
    // ...
    DrawPoint(ctx,point,args){
        // 该方法负责调用  2D Canvas 的 Context 接口将 point 绘制到画板上
    }


    ClaerExtend(ctx,GeometryElemt){
        let rect = GeometryElement.getExtent(); // 该方法返回一个矩形对象
            // 在将数据绘制到画板上之后，在下一次绘制之前需要清空画布，清空一整块画布其实有些浪费

        ctx.Clear(rect);// 我们可以只清空对应图形的外包络矩形区域
    }
}

// 我们已经有了一个点的列表
let p1 = new MyPointClass(0,0);
let p2 = new MyPointClass(0,0);
let p3 = new MyPointClass(0,0);
const Arr = [p1,p2,p3];

// 渲染这个点集就可以
for(let i = 0; i < 3; i++){
    brush.DrawPoint(ctx,Arr[i])
}
```

## 一些栅格算法的思路（ 基于DEM ）
> - 矢量部分、分型部分以及正态云部分的算法相对好实现，去年很多小组都已经实现的很好了，这里就不再赘述。当然，也可以参考我们的代码及文档（不全）。限于个人时间及精力，我无法一一整理。

相较于矢量方向，栅格方向的算法实现起来会稍微复杂一些。并且，这一块的资料非常稀少，老师提供的课件也是英文的，我想这一块是值得仔细探究的。我在这里列出一些我个人的想法，希望能够给大家一些启发。

### 累积表面 (Accumulation Surfaces)
> 参考链接： 
> - [GeoWorld, December 1997, pg. 28](http://www.innovativegis.com/basis/MapAnalysis/Topic5/Topic5.htm)
> - https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/distance-accumulation-algorithm.htm

![splash](./imgs/splash.gif)

> 插图:
> - 注意图中的数字： 平地上至最远处的距离（穿过湖面的距离）
> - a. 是从单个点出发形成的简累积表面的三维视图。曲面上的最低点值为 0，表示它距离起点“0格线间距”。最远的位置位于右上角，距离为:
>   - 60 个网格 * 100 米/网格 = 6000 米
> - b. 将绝对障碍定为无限远。它将最远的可到达位置处的栅格值设为 69 个栅格单位，表示由于绕湖而行使得距离远了 900 米。
> - c. 假设人在冰上走得慢 5 倍。绕湖一周，它仍然距离对面的角落6900米。然而，如果你小心翼翼地跋涉到湖心，就相当于在开阔的土地上跋涉8300米。

- 累积表面生成 (“splash” algorithm)

跟踪简单接近度的飞溅技术有点不太熟悉，但在概念上很容易。想象一下，当你扔下一块石头飞溅物，然后一个涟漪消失，然后另一个，又一个，直到起点周围有一整套同心环时，静止的池塘会发生什么。如果整个池塘的条件相同，效果类似于在起点钉上一把尺子并旋转它，同时划掉通过拖动尺子的记号形成的一组圆圈。在光栅GIS中，每个“波长环”的宽度是一个网格空间。结果不是识别两点之间最短直线长度的单个值；这是一个值的映射，用于识别所有位置和起点之间的最短直线距离。

现在想象一下，扔一把石头飞溅，一个波纹，两个波纹，三个波纹，还有更多的从每个起点辐射出来。当两个波前相遇时，它们停止，干扰点识别起点之间的中间位置。如果你扔一组棍子或胶合板，波纹图案与物体的不规则形状相一致，情况也是如此。GIS中所有模拟飞溅和碰撞的最终结果是从各处到最近起始位置的最短直线距离图；无论是点、线还是多边形。

#### 累积表面的应用
> https://www.youtube.com/watch?v=_KlRRowXv7k