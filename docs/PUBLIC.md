# 实习思路
> - Pan 6.19 `14:00`
> - 本文主要介绍一下个人对空间分析实习的一些想法，水平有限。若有错误，欢迎批评指正。

## 项目结构
具体算法可以首先整合到一个单独的核心算法包（库）中，交互式界面可以在此基础之上构建。在包的编写过程中，注意将相似功能的代码放到一个文件（文件夹）下，并整理好接口以方便调用。例如：
```
/YourApp           |  你的项目
    /core          |  核心算法库
        /Index     |  接口
        /Base      |  基础类
        /Vector    |  矢量
        /Raster    |  栅格
        /Utils     |  通用工具
        /Renderer  |  渲染
    /UI            |  用户交互界面
        /Canvas    |  画板
        /Brushes   |  画刷
        /Actions   |  对话框
        /Utils     |  通用工具
    /Docs          |  文档
    /Others        |  其他
```
> 建议在开始写本次实习的代码之前，先将去年的代码整理一下，按照一定的逻辑组织起来。

### Core
#### Base
核心算法包中，应该首先编写底层的类（点线等），并将一些常用的算法写进去（计算距离、求交等）。这样，我们后续的算法实现就有了基础的对象。交互式绘制和分析时，我们本质上就是在**操作这些对象并不断触发渲染**。这样设计还有一个好处，我们可以依照这些基础类的属性值设计对对应的数据库表，为后续的功能拓展做准备。例如，画板内容的持久化存储，我们在绘制完后可以导出文件，下一次就只需要读取该文件并初始化有关的类。
> 建议将数据和具体的显示（渲染）分开，几何数据和统计数据分开。
#### Renderer 
该类负责将我们的数据画出来，在浏览器中就是调用 2D Canvas 的 Context 接口。可以以类为单位封装，这样只需要几行代码就可以渲染。比如说：
> 以下代码仅仅介绍思路，不可以实际运行
```js
// base.js
class MyPointClass{
    // ...
}

// renderer.js
class brush{
    // 如果不想每次都输入ctx 可以在初始化里就注册 ctx
    // 初始化也可以设置画刷的颜色、宽度等
    // ...
    DrawPoint(ctx,point,args){
        // 该方法负责调用  2D Canvas 的 Context 接口将 point 绘制到画板上
    }


    ClaerExtend(ctx,GeometryElemt){
        let rect = GeometryElement.getExtent(); // 该方法返回一个矩形对象
            // 在将数据绘制到画板上之后，在下一次绘制之前需要清空画布，清空一整块画布其实有些浪费

        ctx.Clear(rect);// 我们可以只清空对应图形的外包络矩形区域
    }
}

// 我们已经有了一个点的列表
let p1 = new MyPointClass(0,0);
let p2 = new MyPointClass(0,0);
let p3 = new MyPointClass(0,0);
const Arr = [p1,p2,p3];

// 渲染这个点集就可以
for(let i = 0; i < 3; i++){
    brush.DrawPoint(ctx,Arr[i])
}
```
#### Raster
该类可能需要维护一个二维数组（甚至更高维度）。然后就是常规的数组遍历操作。

