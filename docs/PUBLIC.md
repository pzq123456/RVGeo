# A Brief Tutorial for Experiment of Spatial Analysis
> - Pan 6.19 `14:00`
> - 本文主要介绍一下个人对空间分析实习的一些想法，**水平有限**。若有错误，欢迎批评指正。
> - 在 `GitHub`上修改 [本文档](https://github.com/pzq123456/RVGeo/tree/main/docs) 。拉取、提交 `Pull Request` 即可。

## 项目结构方面的建议
具体算法可以首先整合到一个单独的核心算法包（库）中，交互式界面可以在此基础之上构建。在包的编写过程中，注意将相似功能的代码放到一个文件（文件夹）下，并整理好接口以方便调用。例如：
```
/YourApp             |      /你的项目
    /core            |          /核心算法库
        /Index       |              /接口
        /Base        |              /基础类
        /Vector      |              /矢量
        /Raster      |              /栅格
        /Utils       |              /通用工具
        /Renderer    |              /渲染
    /UI              |          /用户交互界面
        /Canvas      |              /画板
        /Brushes     |              /画刷
        /Actions     |              /对话框
        /Utils       |              /通用工具
    /Docs            |          /文档
    /Others          |          /其他
```
> 建议在开始写本次实习的代码之前，先将去年的代码整理一下，按照一定的逻辑组织起来。

- `Core/Base/` :
核心算法包中，可以首先编写底层的类（点线等），并将一些常用的算法写进去（计算距离、求交等）。这样，我们后续的算法实现就有了基础的对象。交互式绘制和分析时，我们本质上就是在**操作这些对象并不断触发渲染**。这样设计还有一个好处，我们可以依照这些基础类的属性值设计对对应的数据库表，为后续的功能拓展做准备。例如，画板内容的持久化存储，我们在绘制完后可以导出文件，下一次就只需要读取该文件并初始化有关的类。
> 建议将数据和具体的显示（渲染）分开，几何数据和统计数据分开。
-  `Core/Renderer/` : 
该类负责将我们的数据画出来，在浏览器中就是调用 2D Canvas 的 Context 接口。可以以类为单位封装，这样只需要几行代码就可以渲染。比如说：
> 以下代码仅仅介绍思路，不可以实际运行
```js
// base.js
class MyPointClass{
    // ...
}

// renderer.js
class brush{
    // 如果不想每次都输入ctx 可以在初始化里就注册 ctx
    // 初始化也可以设置画刷的颜色、宽度等
    // ...
    DrawPoint(ctx,point,args){
        // 该方法负责调用  2D Canvas 的 Context 接口将 point 绘制到画板上
    }


    ClaerExtend(ctx,GeometryElemt){
        let rect = GeometryElement.getExtent(); // 该方法返回一个矩形对象
            // 在将数据绘制到画板上之后，在下一次绘制之前需要清空画布，清空一整块画布其实有些浪费

        ctx.Clear(rect);// 我们可以只清空对应图形的外包络矩形区域
    }
}

// 我们已经有了一个点的列表
let p1 = new MyPointClass(0,0);
let p2 = new MyPointClass(0,0);
let p3 = new MyPointClass(0,0);
const Arr = [p1,p2,p3];

// 渲染这个点集就可以
for(let i = 0; i < 3; i++){
    brush.DrawPoint(ctx,Arr[i])
}
```

## 一些栅格算法的思路（ 基于DEM ）
> - 矢量部分、分型部分以及正态云部分的算法相对好实现，去年很多小组都已经实现的很好了，这里就不再赘述。当然，也可以参考我们的代码及文档（不全）。限于个人时间及精力，我无法一一整理。

相较于矢量方向，栅格方向的算法实现起来会稍微复杂一些。并且，这一块的资料非常稀少，老师提供的课件也是英文的，我想这一块是值得仔细探究的。我在这里列出一些我个人的想法，希望能够给大家一些启发。

### 累积表面 (Accumulation Surfaces)
> 参考链接： 
> - [GeoWorld, December 1997, pg. 28](http://www.innovativegis.com/basis/MapAnalysis/Topic5/Topic5.htm)
> - https://pro.arcgis.com/en/pro-app/latest/tool-reference/spatial-analyst/distance-accumulation-algorithm.htm
#### 累积表面生成 (“splash” algorithm)

跟踪简单接近度的飞溅技术有点不太熟悉，但在概念上很容易。想象一下，当你扔下一块石头飞溅物，然后一个涟漪消失，然后另一个，又一个，直到起点周围有一整套同心环时，静止的池塘会发生什么。如果整个池塘的条件相同，效果类似于在起点钉上一把尺子并旋转它，同时划掉通过拖动尺子的记号形成的一组圆圈。在光栅GIS中，每个“波长环”的宽度是一个网格空间。结果不是识别两点之间最短直线长度的单个值；这是一个值的映射，用于识别所有位置和起点之间的最短直线距离。

现在想象一下，扔一把石头飞溅，一个波纹，两个波纹，三个波纹，还有更多的从每个起点辐射出来。当两个波前相遇时，它们停止，干扰点识别起点之间的中间位置。如果你扔一组棍子或胶合板，波纹图案与物体的不规则形状相一致，情况也是如此。GIS中所有模拟飞溅和碰撞的最终结果是从各处到最近起始位置的最短直线距离图；无论是点、线还是多边形。

![splash](./imgs/splash.gif)

图1中的插图（a）是从单个点辐射的简单邻近表面的三维图。曲面上的最低点包含值0，表示它距离起点“0格线间距”。请注意，曲面的形状像一个碗，其值不断增加（1以外、2以外等）。最远的位置位于右上角，距离为60个网格空间*100米/网格空间=6000米。沿着正交和对角线的轻微凹陷是由“飞溅”算法计算的距离的轻微方向变化的结果。

但在现实世界中，形成完美接近碗的连续直线运动很少发生。有效的接近尊重在障碍物周围和通过障碍物的运动，而不是“像乌鸦飞的那样”，而是像乌鸦可能走的那样。假设有一个湖挡住了去路。插图（b）将绝对障碍本身确定为无限遥远（溺水的恐惧/现实）。它将69个网格空间的值指定给最远的可到达位置，表示由于绕湖行驶，距离远了900米。所有地图值的集合表示起点和所有其他位置之间的“最短但不一定是直线”距离。
然而，在冬天，湖面结冰，可以穿过，尽管在湿滑的冰面上速度要慢得多。它代表了一个相对的障碍，阻碍了运动，但并不完全限制运动。插图（c）显示了假设你在冰上走得慢5倍的堆积表面。结果显示，绕湖一周，它仍然距离对面的角落6900米。然而，如果你小心翼翼地跋涉到湖心，就相当于在开阔的土地上跋涉8300米。

#### 累积表面的应用
> https://www.youtube.com/watch?v=_KlRRowXv7k